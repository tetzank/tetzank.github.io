<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dangerous Assembly</title><link>https://tetzank.github.io/</link><description>Recent content on Dangerous Assembly</description><language>en-us</language><lastBuildDate>Sat, 31 Aug 2019 19:53:49 +0200</lastBuildDate><atom:link href="https://tetzank.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Record And Replay</title><link>https://tetzank.github.io/posts/record-and-replay/</link><pubDate>Sat, 31 Aug 2019 19:53:49 +0200</pubDate><guid>https://tetzank.github.io/posts/record-and-replay/</guid><description>Developers spent a significant percentage of their working time debugging their code. A fact many people do not really like to acknowledge as it feels like being unproductive. Software is complex. One usually does not get it right the first time. Therefore, it is very important to have good debugging tools supporting the developer in his quest to find the root cause of the issue. Being able to step backwards in the program execution helps tremendously as we can retrace the execution flow from the crash or assertion failure back to the operation which corrupted the program state.</description></item><item><title>Return Oriented Programming</title><link>https://tetzank.github.io/posts/return-oriented-programming/</link><pubDate>Sat, 15 Jun 2019 21:40:00 +0200</pubDate><guid>https://tetzank.github.io/posts/return-oriented-programming/</guid><description>As a C++ programmer I am well aware of memory errors such as buffer overflows and dangling pointers. There are a lot of good debugging tools available like Memcheck in Valgrind and Address Sanitizer in GCC and Clang which help identifying the root cause leading to the memory corruption. But memory errors are not just bugs resulting in crashes or incorrect program behavior. They are potentially severe security issues. To better understand the risks involved, let us take a look at some basic concepts of exploitation, particularly at return oriented programming (ROP).</description></item><item><title>X-Macros</title><link>https://tetzank.github.io/posts/x-macros/</link><pubDate>Tue, 23 Apr 2019 16:34:00 +0200</pubDate><guid>https://tetzank.github.io/posts/x-macros/</guid><description>A lot of C++ developers try to avoid preprocessor macros like the plague. There are genuine reasons for that. Macros might look like functions, but they behave differently, resulting in confusing bugs when not treated carefully. But even in modern C++, macros still have their use cases. In this post, I want to talk about a special kind of macro called X-macro which is mostly used to generate various code fragments from a single list of elements.</description></item><item><title>Identical Code Folding</title><link>https://tetzank.github.io/posts/identical-code-folding/</link><pubDate>Mon, 07 Jan 2019 09:51:00 +0100</pubDate><guid>https://tetzank.github.io/posts/identical-code-folding/</guid><description>Even more interesting than removing unused functions is consolidating identical instances of templated functions. For each template parameter, the compiler generates a new instance. In case of templated classes, it generates code per template parameter for every member function. The instances can have identical code, e.g., the member function is independent of the template parameters or the types are semantically equivalent for the applied operations. Let&amp;rsquo;s see if we can minimize the code explosion by deduplicating code when it is identical.</description></item><item><title>Removing Unused Code</title><link>https://tetzank.github.io/posts/removing-unused-code/</link><pubDate>Sat, 05 Jan 2019 23:25:03 +0100</pubDate><guid>https://tetzank.github.io/posts/removing-unused-code/</guid><description>I recently went on a little journey to get a better understanding of the linker used in C++. Like many other C++ developers, my mental model of what the linker actually does is very limited. But I&amp;rsquo;m always interested in learning new tricks about the tools I use regularly, especially new optimizations slumbering behind some obscure flag. In this post, we will have a look at the removal of unused functions from the executable and how the linker can help us with this task.</description></item></channel></rss>