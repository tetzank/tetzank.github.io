<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Poems on Dangerous Assembly</title><link>https://tetzank.github.io/poems/</link><description>Recent content in Poems on Dangerous Assembly</description><language>en-us</language><lastBuildDate>Sat, 13 Feb 2021 18:16:04 +0100</lastBuildDate><atom:link href="https://tetzank.github.io/poems/index.xml" rel="self" type="application/rss+xml"/><item><title>Coverage-Based Fuzzing</title><link>https://tetzank.github.io/posts/coverage-based-fuzzing/</link><pubDate>Sat, 08 Feb 2020 12:10:24 +0100</pubDate><guid>https://tetzank.github.io/posts/coverage-based-fuzzing/</guid><description>Software testing is important. Every developer knows that. We all try our very very best to keep up with writing tests. But even a good test coverage is not enough when it comes to writing secure software. The diversity of inputs and internal states of a program is usually too large. Some special cases will be forgotten. Fuzzing tests your software with randomly mutated input data to find bugs and crashes automatically.</description></item><item><title>Structure Definitions for Binary Files</title><link>https://tetzank.github.io/posts/structure-definitions-for-binary-files/</link><pubDate>Thu, 28 Nov 2019 21:21:04 +0100</pubDate><guid>https://tetzank.github.io/posts/structure-definitions-for-binary-files/</guid><description>When dealing with binary file formats, sometimes, one has to look at the raw bits and bytes with a hex editor, especially when debugging a file writer or parser. Reinterpreting the hex numbers to the structures and values in the file format is very tedious. You have to keep all the value offsets and their types in mind to come to the right conclusion. An advanced feature of Okteta, KDE&amp;rsquo;s hex editor, are structure definitions which describe the data layout of the file format such that the GUI can visualize the values and structures contained in the file.</description></item><item><title>Self-Made Karaoke</title><link>https://tetzank.github.io/posts/self-made-karaoke/</link><pubDate>Sun, 03 Nov 2019 23:53:04 +0100</pubDate><guid>https://tetzank.github.io/posts/self-made-karaoke/</guid><description>I am definitely not the singer type. Never went to any karaoke and probably will never do. But for some reason I was intrigued to see, from a technical standpoint, how to create a karaoke song. How does one remove the vocals from a song and make the lyrics appear at the right time? I will show you the poor man&amp;rsquo;s approach of making your own karaoke songs and get them to play on a website.</description></item><item><title>Codegen in Databases</title><link>https://tetzank.github.io/posts/codegen-in-databases/</link><pubDate>Wed, 18 Sep 2019 15:25:08 +0200</pubDate><guid>https://tetzank.github.io/posts/codegen-in-databases/</guid><description>Just-in-time compilation is usually associated with managed languages like Java and C#, or scripting languages like Javascript. As detailed in the previous post, many other applications benefit from ad hoc code generation as well. This post is a tutorial on code generation in relational databases. Relational databases are commonly accessed with the standard query language SQL. The query optimizer generates an optimized query plan and passes it to the query execution engine for processing which in modern systems generates machine code for faster execution.</description></item><item><title>COAT: EDSL for Codegen</title><link>https://tetzank.github.io/posts/coat-edsl-for-codegen/</link><pubDate>Thu, 12 Sep 2019 20:40:01 +0200</pubDate><guid>https://tetzank.github.io/posts/coat-edsl-for-codegen/</guid><description>Code specialization has a huge impact on performance. Tailored code takes advantage of the knowledge about the involved data types and operations. In C++, we can instruct the compiler to generate specialized code at compile-time with the help of template metaprogramming and constant expressions. However, constant evaluation is limited as it cannot leverage runtime information. Just-in-time compilations lifts this limitation by enabling programs to generate code at runtime. In this post, I will present a header-only library providing abstract types and control flow abstractions to make code generation at runtime easier to use.</description></item><item><title>Static Machine Code Analysis</title><link>https://tetzank.github.io/posts/static-machine-code-analysis/</link><pubDate>Tue, 03 Sep 2019 23:54:52 +0200</pubDate><guid>https://tetzank.github.io/posts/static-machine-code-analysis/</guid><description>Modern processors are complex beasts. They reorder instructions in an ever-increasing instruction window and speculatively execute following iterations of a loop by predicting the branch of the loop condition. Both features are meant to extract as much instruction parallelism from the program code as possible to feed superscalar CPUs with enough work. They can execute multiple instructions in a single cycle if there are no dependencies. Static machine code analyzers let us take a look at how our code is executed by modeling the various execution stages of a CPU.</description></item><item><title>Record And Replay</title><link>https://tetzank.github.io/posts/record-and-replay/</link><pubDate>Sat, 31 Aug 2019 19:53:49 +0200</pubDate><guid>https://tetzank.github.io/posts/record-and-replay/</guid><description>Developers spent a significant percentage of their working time debugging their code. A fact many people do not really like to acknowledge as it feels like being unproductive. Software is complex. One usually does not get it right the first time. Therefore, it is very important to have good debugging tools supporting the developer in his quest to find the root cause of the issue. Being able to step backwards in the program execution helps tremendously as we can retrace the execution flow from the crash or assertion failure back to the operation which corrupted the program state.</description></item><item><title>Return Oriented Programming</title><link>https://tetzank.github.io/posts/return-oriented-programming/</link><pubDate>Sat, 15 Jun 2019 21:40:00 +0200</pubDate><guid>https://tetzank.github.io/posts/return-oriented-programming/</guid><description>As a C++ programmer I am well aware of memory errors such as buffer overflows and dangling pointers. There are a lot of good debugging tools available like Memcheck in Valgrind and Address Sanitizer in GCC and Clang which help identifying the root cause leading to the memory corruption. But memory errors are not just bugs resulting in crashes or incorrect program behavior. They are potentially severe security issues. To better understand the risks involved, let us take a look at some basic concepts of exploitation, particularly at return oriented programming (ROP).</description></item><item><title>X-Macros</title><link>https://tetzank.github.io/posts/x-macros/</link><pubDate>Tue, 23 Apr 2019 16:34:00 +0200</pubDate><guid>https://tetzank.github.io/posts/x-macros/</guid><description>A lot of C++ developers try to avoid preprocessor macros like the plague. There are genuine reasons for that. Macros might look like functions, but they behave differently, resulting in confusing bugs when not treated carefully. But even in modern C++, macros still have their use cases. In this post, I want to talk about a special kind of macro called X-macro which is mostly used to generate various code fragments from a single list of elements.</description></item><item><title>Identical Code Folding</title><link>https://tetzank.github.io/posts/identical-code-folding/</link><pubDate>Mon, 07 Jan 2019 09:51:00 +0100</pubDate><guid>https://tetzank.github.io/posts/identical-code-folding/</guid><description>Even more interesting than removing unused functions is consolidating identical instances of templated functions. For each template parameter, the compiler generates a new instance. In case of templated classes, it generates code per template parameter for every member function. The instances can have identical code, e.g., the member function is independent of the template parameters or the types are semantically equivalent for the applied operations. Let&amp;rsquo;s see if we can minimize the code explosion by deduplicating code when it is identical.</description></item><item><title>Removing Unused Code</title><link>https://tetzank.github.io/posts/removing-unused-code/</link><pubDate>Sat, 05 Jan 2019 23:25:03 +0100</pubDate><guid>https://tetzank.github.io/posts/removing-unused-code/</guid><description>I recently went on a little journey to get a better understanding of the linker used in C++. Like many other C++ developers, my mental model of what the linker actually does is very limited. But I&amp;rsquo;m always interested in learning new tricks about the tools I use regularly, especially new optimizations slumbering behind some obscure flag. In this post, we will have a look at the removal of unused functions from the executable and how the linker can help us with this task.</description></item></channel></rss>