<!doctype html><html><head><title>Dangerous Assembly</title><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=https://tetzank.github.io/index.xml title="Dangerous Assembly"></head><body><nav class=header><div class=header-container><a href=/>Dangerous Assembly</a><div class=header-menu><a href=/index.xml>RSS</a>
<a href=https://github.com/tetzank/>github</a>
<a href=/publications/>publications</a>
<a href=/about/>about</a></div></div></nav><div id=content><main><div class=catalogue><a href=https://tetzank.github.io/posts/codegen-in-databases/ class=catalogue-item><div><time datetime="2019-09-18 15:25:08 &#43;0200 CEST" class=catalogue-time>2019-09-18</time><h1 class=catalogue-title>Codegen in Databases</h1><div class=catalogue-line></div><p>Just-in-time compilation is usually associated with managed languages like Java and C#, or scripting languages like Javascript. As detailed in the previous post, many other applications benefit from ad hoc code generation as well. This post is a tutorial on code generation in relational databases. Relational databases are commonly accessed with the standard query language SQL. The query optimizer generates an optimized query plan and passes it to the query execution engine for processing which in modern systems generates machine code for faster execution.</p></div></a><a href=https://tetzank.github.io/posts/coat-edsl-for-codegen/ class=catalogue-item><div><time datetime="2019-09-12 20:40:01 &#43;0200 CEST" class=catalogue-time>2019-09-12</time><h1 class=catalogue-title>COAT: EDSL for Codegen</h1><div class=catalogue-line></div><p>Code specialization has a huge impact on performance. Tailored code takes advantage of the knowledge about the involved data types and operations. In C++, we can instruct the compiler to generate specialized code at compile-time with the help of template metaprogramming and constant expressions. However, constant evaluation is limited as it cannot leverage runtime information. Just-in-time compilations lifts this limitation by enabling programs to generate code at runtime. In this post, I will present a header-only library providing abstract types and control flow abstractions to make code generation at runtime easier to use.</p></div></a><a href=https://tetzank.github.io/posts/static-machine-code-analysis/ class=catalogue-item><div><time datetime="2019-09-03 23:54:52 &#43;0200 CEST" class=catalogue-time>2019-09-03</time><h1 class=catalogue-title>Static Machine Code Analysis</h1><div class=catalogue-line></div><p>Modern processors are complex beasts. They reorder instructions in an ever-increasing instruction window and speculatively execute following iterations of a loop by predicting the branch of the loop condition. Both features are meant to extract as much instruction parallelism from the program code as possible to feed superscalar CPUs with enough work. They can execute multiple instructions in a single cycle if there are no dependencies. Static machine code analyzers let us take a look at how our code is executed by modeling the various execution stages of a CPU.</p></div></a><a href=https://tetzank.github.io/posts/record-and-replay/ class=catalogue-item><div><time datetime="2019-08-31 19:53:49 &#43;0200 CEST" class=catalogue-time>2019-08-31</time><h1 class=catalogue-title>Record And Replay</h1><div class=catalogue-line></div><p>Developers spent a significant percentage of their working time debugging their code. A fact many people do not really like to acknowledge as it feels like being unproductive. Software is complex. One usually does not get it right the first time. Therefore, it is very important to have good debugging tools supporting the developer in his quest to find the root cause of the issue. Being able to step backwards in the program execution helps tremendously as we can retrace the execution flow from the crash or assertion failure back to the operation which corrupted the program state.</p></div></a><a href=https://tetzank.github.io/posts/return-oriented-programming/ class=catalogue-item><div><time datetime="2019-06-15 21:40:00 &#43;0200 CEST" class=catalogue-time>2019-06-15</time><h1 class=catalogue-title>Return Oriented Programming</h1><div class=catalogue-line></div><p>As a C++ programmer I am well aware of memory errors such as buffer overflows and dangling pointers. There are a lot of good debugging tools available like Memcheck in Valgrind and Address Sanitizer in GCC and Clang which help identifying the root cause leading to the memory corruption. But memory errors are not just bugs resulting in crashes or incorrect program behavior. They are potentially severe security issues. To better understand the risks involved, let us take a look at some basic concepts of exploitation, particularly at return oriented programming (ROP).</p></div></a><a href=https://tetzank.github.io/posts/x-macros/ class=catalogue-item><div><time datetime="2019-04-23 16:34:00 &#43;0200 CEST" class=catalogue-time>2019-04-23</time><h1 class=catalogue-title>X-Macros</h1><div class=catalogue-line></div><p>A lot of C++ developers try to avoid preprocessor macros like the plague. There are genuine reasons for that. Macros might look like functions, but they behave differently, resulting in confusing bugs when not treated carefully. But even in modern C++, macros still have their use cases. In this post, I want to talk about a special kind of macro called X-macro which is mostly used to generate various code fragments from a single list of elements.</p></div></a><a href=https://tetzank.github.io/posts/identical-code-folding/ class=catalogue-item><div><time datetime="2019-01-07 09:51:00 &#43;0100 CET" class=catalogue-time>2019-01-07</time><h1 class=catalogue-title>Identical Code Folding</h1><div class=catalogue-line></div><p>Even more interesting than removing unused functions is consolidating identical instances of templated functions. For each template parameter, the compiler generates a new instance. In case of templated classes, it generates code per template parameter for every member function. The instances can have identical code, e.g., the member function is independent of the template parameters or the types are semantically equivalent for the applied operations. Let&rsquo;s see if we can minimize the code explosion by deduplicating code when it is identical.</p></div></a><a href=https://tetzank.github.io/posts/removing-unused-code/ class=catalogue-item><div><time datetime="2019-01-05 23:25:03 &#43;0100 CET" class=catalogue-time>2019-01-05</time><h1 class=catalogue-title>Removing Unused Code</h1><div class=catalogue-line></div><p>I recently went on a little journey to get a better understanding of the linker used in C++. Like many other C++ developers, my mental model of what the linker actually does is very limited. But I&rsquo;m always interested in learning new tricks about the tools I use regularly, especially new optimizations slumbering behind some obscure flag. In this post, we will have a look at the removal of unused functions from the executable and how the linker can help us with this task.</p></div></a></div><div class=pagination><span>1</span></div></main></div></body></html>